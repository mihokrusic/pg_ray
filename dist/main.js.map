{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/classes/state.js","webpack:///./src/classes/states/state.editing.js","webpack:///./src/classes/states/state.running.js","webpack:///./src/classes/vector.js","webpack:///./src/constants.js","webpack:///./src/helpers.js","webpack:///./src/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA,EAAE,QAAQ,mBAAmB,OAAO,kBAAkB,mBAAmB;AACzE,EAAE,QAAQ,kBAAkB,OAAO,iBAAiB,mBAAmB;AACvE,EAAE,QAAQ,iBAAiB,OAAO,kBAAkB,mBAAmB;AACvE,EAAE,QAAQ,kBAAkB,OAAO,mBAAmB,mBAAmB;AACzE;AACA,EAAE,QAAQ,mBAAmB,OAAO,gBAAgB,mBAAmB;AACvE,EAAE,QAAQ,iBAAiB,OAAO,kBAAkB,mBAAmB;AACvE,EAAE,QAAQ,gBAAgB,OAAO,kBAAkB,mBAAmB;AACtE,EAAE,QAAQ,kBAAkB,OAAO,kBAAkB,mBAAmB;AACxE,EAAE,QAAQ,gBAAgB,OAAO,iBAAiB,mBAAmB;AACrE;;AAEO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7FA;AAAA;AAAA;AAAmC;;AAE5B,2BAA2B,4CAAK;;AAEvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACE;AACK;AACJ;;AAE/B,2BAA2B,4CAAK;;AAEvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,4CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD,+BAA+B,gDAAO,sEAAsE,EAAE;AACtK;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,8CAAM,+CAA+C;AAC1F,2EAA2E,kDAAS;;AAEpF,wEAAwE,kDAAS;AACjF,kCAAkC,gDAAO;;AAEzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C,gDAAO;;AAEpD;AACA,+BAA+B,gDAAO;;AAEtC;AACA;;AAEA;AACA,mCAAmC,gDAAO;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,kDAAS;AAC5C;AACA;;AAEA;;AAEA;AACA,2CAA2C,gDAAO;AAClD,6CAA6C,gDAAO;;AAEpD;AACA;;AAEA;AACA;AACA,2FAA2F,kDAAS;AACpG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,kDAAS;AAC5F,kDAAkD,gDAAO;;AAEzD;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,gDAAO;;AAE3D,+DAA+D,gDAAO;AACtE;;AAEA;;AAEA;AACA,2CAA2C,gDAAO;AAClD;AACA;;AAEA;AACA,+CAA+C,gDAAO;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,QAAQ,gDAAO;;AAEf;AACA;AACA;AACA,gBAAgB,gDAAO;;AAEvB,oBAAoB,kDAAS;AAC7B,oBAAoB,gDAAO;AAC3B,oBAAoB,gDAAO;AAC3B,oBAAoB,gDAAO;AAC3B;AACA,aAAa;AACb,SAAS;;AAET;AACA,YAAY,gDAAO;AACnB;AACA;;AAEA;;;;;;;;;;;;;ACzNA;AAAA;AAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,8EAAe,E;;;;;;;;;;;;AChB9B;AAAA;AAAA;AAAoC;AACM;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,8BAA8B,GAAG,6BAA6B;;AAE3F;AACA,mCAAmC,uBAAuB;AAC1D,oCAAoC,8BAA8B,GAAG,6BAA6B;;AAElG,oCAAoC,wBAAwB;AAC5D,oCAAoC,6BAA6B,GAAG,4BAA4B;AAChG;;AAEA,kCAAkC,aAAa;AAC/C;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,sDAAM;AACxB,kBAAkB,sDAAM;;AAExB,oEAAoE,kDAAS;AAC7E;AACA;AACA;AACA,oEAAoE,kDAAS;AAC7E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4EAA4E,kDAAS;;AAErF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6FAA6F,kDAAS;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGe,4EAAa,E;;;;;;;;;;;;AC/L5B;AAAA;AAAA;AAAA;AAA8D;AACA;AAC9B;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,0EAAY;AAC7B,iBAAiB,0EAAY;AAC7B;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI,gDAAO;;AAEX;;AAEA;AACA;AACA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","let globalObstacles = [\r\n\t// outer\r\n\t{ from: { x: -490, y: -290 }, to: { x: 490, y: -290 }, selected: false },\r\n\t{ from: { x: 490, y: -290 }, to: { x: 490, y: 290 }, selected: false },\r\n\t{ from: { x: 490, y: 290 }, to: { x: -490, y: 290 }, selected: false },\r\n\t{ from: { x: -490, y: 290 }, to: { x: -490, y: -290 }, selected: false },\r\n\t// inner\r\n\t{ from: { x: -100, y: -150 }, to: { x: -50, y: 50 }, selected: false },\r\n\t{ from: { x: -400, y: 50 }, to: { x: -100, y: 150 }, selected: false },\r\n\t{ from: { x: 150, y: 50 }, to: { x: 400, y: -150 }, selected: false },\r\n\t{ from: { x: 400, y: -130 }, to: { x: 300, y: -130 }, selected: false },\r\n\t{ from: { x: 50, y: -50 }, to: { x: 300, y: 100 }, selected: false },\r\n];\r\n\r\nexport class State {\r\n\r\n\tconstructor(canvas) {\r\n\t\tif (new.target === State) {\r\n\t        throw new TypeError(\"Cannot construct State instances directly\");\r\n\t    }\r\n\r\n\t\tthis.canvas = canvas;\r\n\t\tthis.context = canvas.getContext('2d');\r\n\t\tthis.canvasOffset = canvas.getBoundingClientRect();\r\n\r\n\t\tthis.pointerMoveEvent = null;\r\n\t\tthis.pointerDownEvent = null;\r\n\t\tthis.pointerUpEvent = null;\r\n\r\n\t\t// TODO: maybe somewhere else?\r\n\t\tthis.rays = [];\r\n\t\tthis.currentRay = {\r\n\t\t\tvector: {},\r\n\t\t\tposition: {}\r\n\t\t};\r\n\r\n\t\tthis.obstacles = globalObstacles;\r\n\t}\r\n\r\n\t/*\r\n\t\tLifecycle methods\r\n\t*/\r\n\tactivate() {\r\n\r\n\t}\r\n\r\n\r\n\t/*\r\n\t\tDOM EVENTS\r\n\t*/\r\n\tonMouseMove(event) {\r\n\t\tthis.pointerMoveEvent = this._getCordinatesFromEvent(event);\r\n\t}\r\n\tonMouseDown(event) {\r\n\t\tthis.pointerDownEvent = this._getCordinatesFromEvent(event);\r\n\t\t//this.pointerDownEvent.button = event.button;\r\n\t}\r\n\tonMouseUp(event) {\r\n\t\tthis.pointerUpEvent = this._getCordinatesFromEvent(event);\r\n\t\t//this.pointerUpEvent.button = event.button;\r\n\t}\r\n\r\n\r\n\tonTouchStart(event) {\r\n\t\tthis.pointerDownEvent = this._getCordinatesFromEvent(event.touches[0]);\r\n\t}\r\n\tonTouchEnd(event) {\r\n\t\tthis.pointerUpEvent = this._getCordinatesFromEvent(event.changedTouches[0]);\r\n\t}\r\n\tonTouchCancel(event) {\r\n\t\tthis.pointerDownEvent = null;\r\n\t\tthis.pointerUpEvent = null;\r\n\t}\r\n\tonTouchMove(event) {\r\n\t\tthis.pointerMoveEvent = this._getCordinatesFromEvent(event.touches[0]);\r\n\t}\r\n\r\n\r\n\tonKeyUp(event) {}\r\n\r\n\r\n\tonUpdate(dt) {}\r\n\tonRender(dt) {}\r\n\r\n\t/*\r\n\t\tHelper methods\r\n\t*/\r\n\t_getCordinatesFromEvent(event) {\r\n\t\treturn {\r\n\t\t\tx: event.clientX - this.canvasOffset.x - this.canvas.width / 2,\r\n\t\t\ty: (event.clientY * -1) + this.canvasOffset.y + this.canvas.height / 2\r\n\t\t};\r\n\t}\r\n}","import { State } from './../state';\r\n\r\nexport class EditingState extends State {\r\n\r\n\tconstructor(canvas) {\r\n\t\tsuper(canvas);\r\n\r\n\t\tthis.firstPoint = null;\r\n\t\tthis.lastPoint = null;\r\n\t}\r\n\r\n\tactivate() {\r\n\t\tconsole.log(\"editing, activate!\");\r\n\t}\r\n\r\n\tonMouseUp(event) {\r\n\t\tsuper.onMouseUp(event);\r\n\r\n\t\tif (!this.firstPoint)\r\n\t\t\tthis.firstPoint = this.pointerMoveEvent;\r\n\t\telse\r\n\t\t\tthis.lastPoint = this.pointerMoveEvent;\r\n\r\n\t}\r\n\r\n\tonKeyUp(event) {\r\n\t\tsuper.onKeyUp(event);\r\n\r\n\t\tswitch (event.keyCode)\r\n\t\t{\r\n\t\t\tcase 32: // SPACE\r\n\t\t\t\tthis.running = !this.running;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tonUpdate(dt) {\r\n\t\tif (this.firstPoint && this.lastPoint) {\r\n\t\t\tthis.obstacles.push({\r\n\t\t\t\tfrom: {\r\n\t\t\t\t\tx: this.firstPoint.x,\r\n\t\t\t\t\ty: this.firstPoint.y\r\n\t\t\t\t},\r\n\t\t\t\tto: {\r\n\t\t\t\t\tx: this.lastPoint.x,\r\n\t\t\t\t\ty: this.lastPoint.y\r\n\t\t\t\t},\r\n\t\t\t\tselected: false\r\n\t\t\t});\r\n\r\n\t\t\tthis.firstPoint = null;\r\n\t\t\tthis.lastPoint = null;\r\n\t\t}\r\n\t}\r\n\r\n\tonRender(dt) {\r\n\t    helpers.drawObstacles(this.context, this.obstacles);\r\n\r\n    \tif (this.firstPoint) {\r\n\t    \thelpers.drawCircle(this.context, this.firstPoint, 4, \"green\");\r\n\t    \thelpers.drawLine(this.context, this.firstPoint, this.pointerMoveEvent, \"green\", 1);\r\n\t    \thelpers.drawCircle(this.context, this.pointerMoveEvent, 4, \"green\");\r\n    \t}\r\n\t}\r\n\r\n}\r\n","import { State } from './../state';\r\nimport { Vector } from './../vector';\r\nimport Constants from './../../constants';\r\nimport Helpers from './../../helpers';\r\n\r\nexport class RunningState extends State {\r\n\r\n    constructor(canvas) {\r\n        super(canvas);\r\n        this.running = true;\r\n    }\r\n\r\n    activate() {\r\n        this.rays = [];\r\n    }\r\n\r\n    onKeyUp(event) {\r\n        super.onKeyUp(event);\r\n        switch (event.keyCode)\r\n        {\r\n            case 32: // SPACE\r\n                this.running = !this.running;\r\n                break;\r\n            // TESTS\r\n            // case 49: // 1\r\n            //     this.pointerUpEvent = { x: 434, y: -139};\r\n            //     this.pointerDownEvent = { x: 64, y: -80};\r\n            //     this.pointerMoveEvent = this.pointerUpEvent;\r\n            //     break;\r\n        }\r\n    }\r\n\r\n    /*\r\n    MOVE\r\n    */\r\n    getRayLength(ray) {\r\n        return _.sumBy(ray.segments, function(segment) { return segment.finished ? 0 : Helpers.distanceBetweenTwoPoints(segment.startPosition, segment.endPosition); });\r\n    }\r\n\r\n    onUpdate(dt) {\r\n        // Fire ray\r\n        if (this.pointerUpEvent) {\r\n            this.fireRay(dt);\r\n        }\r\n\r\n        this.calculateRayPositions(dt);\r\n    }\r\n\r\n    fireRay(dt) {\r\n        // Calculate next ray properties\r\n        var angle = Math.atan2(this.pointerUpEvent.y - this.pointerDownEvent.y, this.pointerUpEvent.x - this.pointerDownEvent.x);\r\n        this.currentRay.vector = new Vector(Math.cos(angle), Math.sin(angle)).normalize(); // TODO: double creation, blah\r\n        this.currentRay.position = this.currentRay.vector.multiplyByScalar(Constants.ray.length).addVector(this.pointerDownEvent);\r\n\r\n        var interSectionCheck = this.currentRay.vector.multiplyByScalar(Constants.ray.intersectionCheckLineLength).addVector(this.pointerDownEvent);\r\n        var closestIntersection = Helpers.getClosestIntersectionLine(this.pointerDownEvent, interSectionCheck, this.obstacles);\r\n\r\n        if (!closestIntersection.obstacle) {\r\n            console.error(\"Can't find next intersection!\");\r\n        }\r\n\r\n        this.currentRay.intersectionPoint = closestIntersection.point;\r\n        this.currentRay.nextObstacle = closestIntersection.obstacle;\r\n\r\n        if (this.currentRay.nextObstacle) {\r\n            this.currentRay.sideOfObstacle = Helpers.checkSideOfLine(this.currentRay.nextObstacle, this.currentRay.position);\r\n\r\n            // Normal vector\r\n            var normalVector = Helpers.getNormalVector(this.currentRay.nextObstacle, this.currentRay.intersectionPoint, this.currentRay.sideOfObstacle);\r\n\r\n            this.currentRay.normalVector = normalVector.vector;\r\n            this.currentRay.normalVectorEndPoint = normalVector.endPoint;\r\n\r\n            // Reflection vector\r\n            var reflectionVector = Helpers.getReflectionVector(this.currentRay.vector, this.currentRay.normalVector, this.currentRay.intersectionPoint);\r\n            this.currentRay.reflectionVector = reflectionVector.vector;\r\n            this.currentRay.reflectionVectorEndPoint = reflectionVector.endPoint;\r\n        } else {\r\n            this.currentRay.normalVector = null;\r\n            this.currentRay.normalVectorEndPoint = null;\r\n            this.currentRay.reflectionVector = null;\r\n            this.currentRay.reflectionVectorEndPoint = null;\r\n        }\r\n\r\n        console.log(\"A0\");\r\n        if (this.currentRay.intersectionPoint) {\r\n            console.log(\"A1\");\r\n            var newRay = {\r\n                bounces: 0,\r\n                segments: [{\r\n                    finished: false,\r\n                    bounced: false,\r\n                    vector: this.currentRay.vector,\r\n                    startPosition: this.pointerDownEvent,\r\n                    endPosition: this.pointerDownEvent,\r\n                    intersectionPoint: this.currentRay.intersectionPoint,\r\n                    nextObstacle: this.currentRay.nextObstacle,\r\n                    sideOfObstacle: this.currentRay.sideOfObstacle,\r\n                    normalVector: this.currentRay.normalVector,\r\n                    normalVectorEndPoint: this.currentRay.normalVectorEndPoint,\r\n                    reflectionVector: this.currentRay.reflectionVector,\r\n                    reflectionVectorEndPoint: this.currentRay.reflectionVectorEndPoint\r\n                }]\r\n            };\r\n\r\n            this.rays.push(newRay);\r\n        }\r\n\r\n        this.pointerUpEvent = null;\r\n        this.pointerDownEvent = null;\r\n    }\r\n\r\n    calculateRayPositions(dt) {\r\n        var frameMoveAmount = dt * Constants.ray.speed;\r\n        var newSegments = [];\r\n        this.rays.forEach((ray) => {\r\n\r\n            let currentRayLength = this.getRayLength(ray);\r\n\r\n            ray.segments.forEach((segment, index, array) => {\r\n                let currentSegmentLength = Helpers.distanceBetweenTwoPoints(segment.startPosition, segment.endPosition);\r\n                let distanceToIntersection = Helpers.distanceBetweenTwoPoints(segment.endPosition, segment.intersectionPoint);\r\n\r\n                let maxSegmentMoveAmount = Math.min(frameMoveAmount, distanceToIntersection);\r\n                let remainderMove = frameMoveAmount - maxSegmentMoveAmount;\r\n\r\n                let moveStartPosition = 0;\r\n                if (index === 0) {\r\n                    moveStartPosition = Math.max(0, (currentRayLength + frameMoveAmount) - Constants.ray.length);\r\n                    if (moveStartPosition > currentSegmentLength) {\r\n                        segment.finished = true;\r\n                    }\r\n                }\r\n\r\n                let justBounced = false;\r\n                if (!segment.bounced && (distanceToIntersection - maxSegmentMoveAmount < 0.001)) {\r\n                    justBounced = true;\r\n\r\n                    while (remainderMove > 0) {\r\n                        var newSegment = {\r\n                            finished: false,\r\n                            bounced: false,\r\n                            vector: segment.reflectionVector,\r\n                            startPosition: segment.intersectionPoint,\r\n                        };\r\n                        var interSectionCheck = newSegment.vector.multiplyByScalar(Constants.ray.intersectionCheckLineLength).addVector(newSegment.startPosition);\r\n                        var closestIntersection = Helpers.getClosestIntersectionLine(newSegment.startPosition, interSectionCheck, this.obstacles);\r\n\r\n                        if (!closestIntersection.obstacle) {\r\n                            console.error(\"Can't find next intersection!\");\r\n                        }\r\n\r\n                        newSegment.intersectionPoint = closestIntersection.point;\r\n                        newSegment.nextObstacle = closestIntersection.obstacle;\r\n                        newSegment.sideOfObstacle = Helpers.checkSideOfLine(closestIntersection.obstacle, newSegment.startPosition);\r\n\r\n                        var newSegmentDistanceToIntersection = Helpers.distanceBetweenTwoPoints(newSegment.startPosition, newSegment.intersectionPoint);\r\n                        var newSegmentMoveAmount = Math.min(remainderMove, newSegmentDistanceToIntersection);\r\n\r\n                        newSegment.endPosition = newSegment.vector.multiplyByScalar(newSegmentMoveAmount).addVector(newSegment.startPosition);\r\n\r\n                        // Normal vector\r\n                        var normalVector = Helpers.getNormalVector(newSegment.nextObstacle, newSegment.intersectionPoint, newSegment.sideOfObstacle);\r\n                        newSegment.normalVector = normalVector.vector;\r\n                        newSegment.normalVectorEndPoint = normalVector.endPoint;\r\n\r\n                        // Reflection vector\r\n                        var reflectionVector = Helpers.getReflectionVector(newSegment.vector, newSegment.normalVector, newSegment.intersectionPoint);\r\n                        newSegment.reflectionVector = reflectionVector.vector;\r\n                        newSegment.reflectionVectorEndPoint = reflectionVector.endPoint;\r\n\r\n                        newSegments.push(newSegment);\r\n                        remainderMove -= newSegmentMoveAmount;\r\n                    }\r\n                }\r\n\r\n                if (!segment.finished && moveStartPosition > 0) {\r\n                    segment.startPosition = segment.vector.multiplyByScalar(moveStartPosition).addVector(segment.startPosition);\r\n                }\r\n\r\n                if (!segment.bounced) {\r\n                    segment.endPosition = segment.vector.multiplyByScalar(maxSegmentMoveAmount).addVector(segment.endPosition);\r\n                }\r\n\r\n                if (!segment.bounced) {\r\n                    segment.bounced = justBounced;\r\n                }\r\n            });\r\n\r\n            ray.segments.push(...newSegments);\r\n            ray.segments = ray.segments.filter((segment) => !segment.finished);\r\n        });\r\n\r\n        this.rays = this.rays.filter((ray) => ray.segments.length > 0);\r\n    }\r\n\r\n    onRender(dt) {\r\n        Helpers.drawObstacles(this.context, this.obstacles);\r\n\r\n        // Rays\r\n        this.rays.forEach((ray) => {\r\n            ray.segments.forEach((segment) => {\r\n                Helpers.drawRay(this.context, segment, \"green\");\r\n\r\n                if (Constants.debugLines) {\r\n                    Helpers.drawLine(this.context, segment.intersectionPoint, segment.normalVectorEndPoint, \"orange\", 1);\r\n                    Helpers.drawLine(this.context, segment.intersectionPoint, segment.reflectionVectorEndPoint, \"blue\", 1);\r\n                    Helpers.drawCircle(this.context, segment.intersectionPoint, 4, \"#91C8FF\");\r\n                }\r\n            });\r\n        });\r\n\r\n        if (this.pointerMoveEvent && this.pointerDownEvent && !this.pointerUpEvent) {\r\n            Helpers.drawLine(this.context, this.pointerDownEvent, this.pointerMoveEvent, \"#44E500\", 1);\r\n        }\r\n    }\r\n\r\n}\r\n","export class Vector {\r\n\r\n\tconstructor(x, y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\r\n\tget length() {\r\n\t\treturn Math.sqrt(Math.abs(Math.pow(this.y, 2) + Math.pow(this.x, 2)));\r\n\t}\r\n\r\n\tflip() {\r\n\t\treturn new Vector(-this.x, -this.y);\r\n\t}\r\n\r\n\tnormalize() {\r\n\t\tvar length = this.length;\r\n\t\treturn new Vector(this.x / length, this.y / length);\r\n\t}\r\n\r\n\taddVector(vector) {\r\n\t\treturn new Vector(this.x + vector.x, this.y + vector.y);\r\n\t}\r\n\r\n\tsubstract(vector) {\r\n\t\treturn new Vector(this.x - vector.x, this.y + vector.y);\r\n\t}\r\n\r\n\tsubstractFrom(vector) {\r\n\t\treturn new Vector(vector.x - this.x, vector.y + this.y);\r\n\t}\r\n\r\n\tmultiplyByScalar(scalar) {\r\n\t\treturn new Vector(this.x * scalar, this.y * scalar);\r\n\t}\r\n}\r\n\r\n","class Constants {\r\n    constructor() {\r\n        this.ray = {\r\n            speed: 500,\r\n            length: 50,\r\n            maxBounces: 50,\r\n            normalLineLength: 25,\r\n            reflectionLineLength: 25,\r\n            intersectionCheckLineLength: 10000,\r\n            minDistanceIntersectionTrigger: 0.1\r\n        };\r\n\r\n        this.debugLines = false;\r\n    }\r\n}\r\n\r\nexport default new Constants();","import Constants from './constants';\r\nimport { Vector } from './classes/vector';\r\n\r\nclass Helpers {\r\n    intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\r\n        // line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/\r\n        // Determine the intersection point of two line segments\r\n        // Return FALSE if the lines don't intersect\r\n\r\n        // Check if none of the lines are of length 0\r\n        if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\r\n            return false;\r\n        }\r\n\r\n        var denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\r\n\r\n        // Lines are parallel\r\n        if (denominator === 0) {\r\n            return false;\r\n        }\r\n\r\n        let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\r\n        let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\r\n\r\n        // is the intersection along the segments\r\n        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\r\n            return false;\r\n        }\r\n\r\n        // Return a object with the x and y coordinates of the intersection\r\n        let x = x1 + ua * (x2 - x1);\r\n        let y = y1 + ua * (y2 - y1);\r\n\r\n        return {x, y};\r\n    }\r\n\r\n    isPointOnLine(point, lineStart, lineEnd) {\r\n        // if AC is horizontal\r\n        if (lineStart.x === lineEnd.x) return lineStart.x == point.x;\r\n\r\n        // if AC is vertical\r\n        if (lineStart.y === lineEnd.y) return lineStart.y == point.y;\r\n\r\n        // match the gradients\r\n        return this.slopeForTwoPoints(lineStart, lineEnd) === this.slopeForTwoPoints(point, lineEnd);\r\n    }\r\n\r\n    distanceBetweenTwoPoints(point1, point2) {\r\n        return Math.sqrt(Math.abs(Math.pow(point1.y - point2.y, 2) + Math.pow(point1.x - point2.x, 2)));\r\n    }\r\n\r\n    slopeForTwoPoints(point1, point2) {\r\n        if (point2.x === point1.x)\r\n            return undefined;\r\n\r\n        var slope = (point2.y - point1.y) / (point2.x - point1.x);\r\n        return slope;\r\n    }\r\n\r\n    // Outer product\r\n    checkSideOfLine(line, point) {\r\n        return Math.sign((point.x - line.from.x) * (line.to.y - line.from.y) - (point.y - line.from.y) * (line.to.x - line.from.x));\r\n    }\r\n\r\n    // Dot product\r\n    dotProduct(vector1, vector2) {\r\n        return (vector1.x * vector2.x) + (vector1.y * vector2.y);\r\n    }\r\n\r\n    radToDeg(rad) {\r\n        return rad * (180 / Math.PI);\r\n    }\r\n\r\n    degToRad(deg) {\r\n        return deg * (Math.PI / 180);\r\n    }\r\n\r\n    drawGrid(context, canvas) {\r\n        //drawLine(context, { x: 0, y: -canvas.height / 2 }, { x: 0, y: canvas.height / 2 }, \"silver\", .5);\r\n\r\n        let i;\r\n        for (i = -canvas.width / 2; i <= canvas.width / 2; i+=50)\r\n            this.drawLine(context, { x: i, y: -canvas.height / 2 }, { x: i, y: canvas.height / 2 }, \"silver\", 0.5);\r\n\r\n        for (i = -canvas.height / 2; i <= canvas.height / 2; i+=50) {\r\n            this.drawLine(context, { x: -canvas.width / 2, y: i }, { x: canvas.width / 2, y: i }, \"silver\", 0.5);\r\n        }\r\n\r\n        this.drawCircle(context, { x: 0, y: 0 }, 2, \"silver\");\r\n    }\r\n\r\n    drawObstacles(context, obstacles) {\r\n        obstacles.forEach((item) => {\r\n            this.drawLine(context, item.from, item.to, (item.selected ? \"red\" : \"gray\"), 2);\r\n        });\r\n    }\r\n\r\n    drawText(context, x, y, text, font, color) {\r\n        context.font = font;\r\n        context.fillStyle = color;\r\n        context.fillText(text, x, y);\r\n    }\r\n\r\n    drawCircle(context, point, radius, color) {\r\n        context.beginPath();\r\n        context.arc(point.x, point.y, radius, 0, Math.PI * 2, false);\r\n        context.fillStyle = color;\r\n        context.fill();\r\n    }\r\n\r\n    drawRay(context, ray, color) {\r\n        context.beginPath();\r\n        context.moveTo(ray.startPosition.x, ray.startPosition.y);\r\n        context.lineTo(ray.endPosition.x, ray.endPosition.y);\r\n        context.strokeStyle = color;\r\n        context.lineWidth = 2;\r\n        context.stroke();\r\n    }\r\n\r\n    drawLine(context, fromPoint, toPoint, color, lineWidth) {\r\n        context.beginPath();\r\n        context.moveTo(fromPoint.x, fromPoint.y);\r\n        context.lineTo(toPoint.x, toPoint.y);\r\n        context.strokeStyle = color;\r\n        context.lineWidth = lineWidth;\r\n        context.stroke();\r\n    }\r\n\r\n    getNormalVector(obstacle, intersectionPoint, sideOfObstacle) {\r\n        var normalVectorSlope = this.slopeForTwoPoints(obstacle.from, obstacle.to);\r\n        var normalVector = (normalVectorSlope === undefined)\r\n            ? new Vector(1, 0)\r\n            : new Vector(normalVectorSlope, -1).normalize();\r\n\r\n        var normalVectorEndPosition = normalVector.multiplyByScalar(Constants.ray.normalLineLength).addVector(intersectionPoint);\r\n        var normalSideOfObstacle = this.checkSideOfLine(obstacle, normalVectorEndPosition);\r\n        if (sideOfObstacle !== normalSideOfObstacle) {\r\n            normalVector = normalVector.multiplyByScalar(-1).normalize();\r\n            normalVectorEndPosition = normalVector.multiplyByScalar(Constants.ray.normalLineLength).addVector(intersectionPoint);\r\n        }\r\n\r\n        return {\r\n            vector: normalVector,\r\n            endPoint: normalVectorEndPosition\r\n        };\r\n    }\r\n\r\n    getReflectionVector(rayVector, normalVector, intersectionPoint) {\r\n        // (v + 2 * n * (-v dot n))\r\n        var dot = this.dotProduct(normalVector, rayVector.flip());\r\n        var reflectionVector = normalVector.multiplyByScalar(dot * 2).addVector(rayVector).normalize();\r\n        var reflectionVectorEndPosition = reflectionVector.multiplyByScalar(Constants.ray.reflactionLineLength).addVector(intersectionPoint);\r\n\r\n        return {\r\n            vector: reflectionVector,\r\n            endPoint: reflectionVectorEndPosition\r\n        };\r\n    }\r\n\r\n    getClosestIntersectionLine(startPosition, endPosition, obstacles) {\r\n        var closestObstacle = null, closestIntersectionPoint = null;\r\n        var leastDistance = null;\r\n\r\n        obstacles.forEach((obstacle) => {\r\n            var pointOnLine = this.isPointOnLine(startPosition, obstacle.from, obstacle.to);\r\n            var intersectPoint = !pointOnLine && this.intersect(\r\n                                    startPosition.x, startPosition.y, endPosition.x, endPosition.y,\r\n                                    obstacle.from.x, obstacle.from.y, obstacle.to.x, obstacle.to.y);\r\n\r\n            if (!pointOnLine && intersectPoint) {\r\n                var currentDistance = this.distanceBetweenTwoPoints(startPosition, intersectPoint);\r\n                if ((!leastDistance || leastDistance > currentDistance) && currentDistance > Constants.ray.minDistanceIntersectionTrigger) {\r\n                    leastDistance = currentDistance;\r\n                    closestObstacle = obstacle;\r\n                    closestIntersectionPoint = intersectPoint;\r\n                }\r\n            }\r\n            obstacle.selected = false;\r\n        });\r\n\r\n        if (closestObstacle)\r\n            closestObstacle.selected = true;\r\n\r\n        return {\r\n            point: closestIntersectionPoint,\r\n            obstacle: closestObstacle\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport default new Helpers();","import { RunningState } from './classes/states/state.running';\r\nimport { EditingState } from './classes/states/state.editing';\r\nimport Helpers from './helpers';\r\n\r\n/* TODO\r\n\t- move to typescript\r\n\t- gulp to automatically transpile\r\n\t- module loader instead of including everything\r\n\t- double buffer\r\n\t- state machine for different states (running, editing, paused...)\r\n\t- cordinate system for canvas?\r\n*/\r\n\r\n// Move to class\r\nvar canvas, context;\r\nvar animationHandle;\r\nvar lastTimestamp;\r\n\r\n// Events\r\nwindow.runOrPause = function() {\r\n    document.getElementById('editButton').removeAttribute(\"disabled\");\r\n    document.getElementById('runPauseButton').innerHTML = (states.current.running ? 'Pause' : 'Run');\r\n    states.current = states.running;\r\n    states.current.activate();\r\n};\r\n\r\nwindow.edit = function() {\r\n    document.getElementById('runPauseButton').innerHTML = 'Run';\r\n    document.getElementById('editButton').setAttribute(\"disabled\",\"disabled\");\r\n    states.current = states.editing;\r\n    states.current.activate();\r\n};\r\n\r\n// Create & start\r\ncanvas = document.getElementById('gameCanvas');\r\ncontext = canvas.getContext('2d');\r\ncontext.transform(1, 0, 0, -1, canvas.width / 2, canvas.height / 2);\r\n\r\ncanvas.addEventListener(\"mousemove\", (event) => onMouseMove(event));\r\ncanvas.addEventListener(\"mouseup\", (event) => onMouseUp(event));\r\ncanvas.addEventListener(\"mousedown\", (event) => onMouseDown(event));\r\n\r\ncanvas.addEventListener(\"touchstart\", (event) => onTouchStart(event), false);\r\ncanvas.addEventListener(\"touchend\", (event) => onTouchEnd(event), false);\r\ncanvas.addEventListener(\"touchcancel\", (event) => onTouchCancel(event), false);\r\ncanvas.addEventListener(\"touchmove\", (event) => onTouchMove(event), false);\r\n\r\ncanvas.addEventListener(\"keyup\", (event) => onKeyUp(event));\r\n\r\n// Initialize states\r\nvar states = {\r\n    current: null,\r\n    running: new RunningState(canvas),\r\n    editing: new EditingState(canvas)\r\n};\r\nstates.current = states.running;\r\n\r\nanimationHandle = window.requestAnimationFrame((timestamp) => onUpdate(timestamp));\r\n\r\nwindow.runOrPause();\r\n\r\n\r\nfunction onMouseMove(event) {\r\n    states.current.onMouseMove(event);\r\n}\r\nfunction onMouseUp(event) {\r\n    states.current.onMouseUp(event);\r\n}\r\nfunction onMouseDown(event) {\r\n    states.current.onMouseDown(event);\r\n}\r\n\r\n\r\nfunction onTouchStart(event) {\r\n    states.current.onTouchStart(event);\r\n}\r\nfunction onTouchEnd(event) {\r\n    states.current.onTouchEnd(event);\r\n}\r\nfunction onTouchCancel(event) {\r\n    states.current.onTouchCancel(event);\r\n}\r\nfunction onTouchMove(event) {\r\n    states.current.onTouchMove(event);\r\n}\r\n\r\n\r\nfunction onKeyUp(event) {\r\n    states.current.onKeyUp(event);\r\n    // if (event.keyCode === 81) {\r\n    // \tvar dt = 0.015;\r\n\r\n    // \t// update state\r\n    // \tstates.current.onUpdate(dt);\r\n\r\n    // \t// render\r\n    // \tcontext.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\r\n    // \tHelpers.drawGrid(context, canvas);\r\n\r\n    // \tstates.current.onRender(dt);\r\n    // }\r\n}\r\n\r\n\r\nfunction onUpdate(timestamp) {\r\n    if (!lastTimestamp)\r\n        lastTimestamp = timestamp;\r\n\r\n    var dt = (timestamp - lastTimestamp) / 1000;\r\n\r\n    // update state\r\n    states.current.onUpdate(dt);\r\n\r\n    // render\r\n    context.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\r\n    Helpers.drawGrid(context, canvas);\r\n\r\n    states.current.onRender(dt);\r\n\r\n    // timing\r\n    lastTimestamp = timestamp;\r\n    animationHandle = window.requestAnimationFrame((timestamp) => onUpdate(timestamp));\r\n}\r\n"],"sourceRoot":""}